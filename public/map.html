<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nebulous - Map</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link href="/styles.css" rel="stylesheet" />
    <link href="/timeElapsed.css" rel="stylesheet" />
    <style>
      .map-container {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 20px 0;
        position: relative;
        z-index: 1;
      }

      canvas {
        border: 1px solid #333;
        background-color: #111;
        cursor: grab;
        max-width: 100%;
        height: auto;
      }

      canvas:active {
        cursor: grabbing;
      }

      .sector-info {
        background-color: rgba(20, 20, 30, 0.7);
        border-radius: 10px;
        border: 1px solid #333;
        padding: 20px;
        margin-top: 20px;
      }

      .sector-code {
        font-family: "Courier New", monospace;
        font-size: 20px;
        font-weight: bold;
        color: #4fd1c5;
        text-align: center;
        margin: 10px 0;
      }

      .btn-generate {
        background-color: #198754;
        border-color: #157347;
        margin-bottom: 15px;
      }

      .btn-generate:disabled {
        background-color: #597a68;
        border-color: #495f53;
        cursor: not-allowed;
        opacity: 0.6;
      }

      body {
        display: block !important;
        justify-content: normal !important;
        align-items: normal !important;
        height: auto !important;
      }

      .ml-2 {
        margin-left: 0.5rem;
      }

      .player-marker {
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.6;
        }
      }

      .player-label {
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div class="dashboard-container">
      <div class="sidebar">
        <a href="dashboard.html" class="nav-btn">Dashboard</a>
        <a href="planet.html" class="nav-btn">Planet</a>
        <a href="mecha.html" class="nav-btn">Mecha</a>
        <a href="buildings.html" class="nav-btn">Buildings</a>
        <a href="extraction.html" class="nav-btn">Extraction</a>
        <a href="research.html" class="nav-btn">Research</a>
        <a href="events.html" class="nav-btn">Events</a>
        <a href="slots.html" class="nav-btn">Slots</a>
        <a href="guide.html" class="nav-btn">Guide</a>
        <a href="map.html" class="nav-btn active">Map</a>
      </div>

      <!-- Main Content Area -->
      <div class="flex-grow-1 d-flex flex-column">
        <!-- Header with user info and logout -->
        <div class="header">
          <h3>Nebulous - Map</h3>
          <div class="d-flex align-items-center">
            <div class="user-info">
              Welcome, <span id="username">User</span>
            </div>
            <button id="logoutBtn" class="logout-btn">Logout</button>
          </div>
        </div>

        <!-- Main content -->
        <div class="main-content">
          <h2 class="page-title">Sector Map</h2>

          <!-- Map Controls -->
          <div class="row mb-4">
            <div class="col-md-12 text-center">
              <button id="generateSector" class="btn btn-success btn-generate">
                Generate Random Sector
              </button>
              <button id="refreshMap" class="btn btn-primary ml-2">
                Refresh Player Positions
              </button>
              <button id="diagnoseSectors" class="btn btn-warning ml-2">
                Diagnose Sectors
              </button>

              <p class="text-muted" id="map-instructions">
                Click on the map to zoom in and reveal sector divisions. Use
                mouse wheel to zoom, drag to pan.
              </p>
            </div>
          </div>

          <!-- Map Canvas -->
          <div class="map-container">
            <canvas id="mapCanvas" width="640" height="640"></canvas>
          </div>

          <!-- Sector Information -->
          <div class="row mt-4">
            <div class="col-md-12">
              <div class="sector-info">
                <h4 class="text-center">Sector Information</h4>
                <div id="sector-display" style="display: none">
                  <p class="sector-code" id="sector-code">Not yet generated</p>
                  <p class="text-center" id="sector-description">
                    Generate a sector to begin exploration.
                  </p>

                  <p class="text-center mt-3">
                    <span id="player-count">0</span> other players detected in
                    universe.
                    <span class="text-muted"
                      >(Your position shown in red, others in yellow)</span
                    >
                  </p>
                </div>
                <div id="no-sector" class="text-center">
                  <p>
                    No sector assigned. Click the Generate button to randomly
                    assign a sector.
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Error and success message containers -->
    <div
      id="error-message"
      class="alert alert-danger"
      style="
        display: none;
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
      "
    ></div>
    <div
      id="success-message"
      class="alert alert-success"
      style="
        display: none;
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
      "
    ></div>

    <!-- Shared JavaScript -->
    <script src="/js/script.js"></script>
    <script src="/js/timeElapsed.js"></script>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        console.log("Page loaded - initializing map");

        // Check if user is logged in (token exists)
        const token = localStorage.getItem("token");
        if (!token) {
          window.location.href = "login.html";
          return;
        }

        // Fetch user data and initialize map once we have the username
        fetchUserDataForMap();
      });

      // Special version of fetchUserData that initializes the map afterward
      async function fetchUserDataForMap() {
        try {
          const token = localStorage.getItem("token");
          const response = await fetch("/api/user", {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (response.ok) {
            const userData = await response.json();
            const usernameElement = document.getElementById("username");
            if (usernameElement) {
              usernameElement.textContent = userData.username;
            }

            // Initialize map after we have the username
            initializeMap();
          } else {
            // If token is invalid, redirect to login
            localStorage.removeItem("token");
            window.location.href = "login.html";
          }
        } catch (error) {
          console.error("Error fetching user data:", error);
          showError("Error loading user data. Please try refreshing the page.");
        }
      }

      function showError(message) {
        const errorDiv = document.getElementById("error-message");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";

        setTimeout(() => {
          errorDiv.style.display = "none";
        }, 5000);
      }

      function showSuccess(message) {
        const successDiv = document.getElementById("success-message");
        successDiv.textContent = message;
        successDiv.style.display = "block";

        setTimeout(() => {
          successDiv.style.display = "none";
        }, 5000);
      }

      function initializeMap() {
        console.log("Initializing map...");

        const canvas = document.getElementById("mapCanvas");
        const ctx = canvas.getContext("2d");
        const generateBtn = document.getElementById("generateSector");
        const username = document.getElementById("username").textContent;

        if (!username || username === "User") {
          console.error("Username not available yet, retrying in 1 second");
          setTimeout(initializeMap, 1000);
          return;
        }

        console.log("Map initialization for user:", username);

        let squares = [{ x: 0, y: 0, size: 640, level: 0 }];
        let clickCount = 0;
        let selectedPosition = null;

        // Variables for zoom and pan
        let zoomLevel = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        async function loadUserSectorFromServer() {
          try {
            const token = localStorage.getItem("token");
            if (!token) return;

            const response = await fetch("/api/sector", {
              headers: {
                Authorization: `Bearer ${token}`,
              },
            });

            if (response.status === 404) {
              // No sector found on server, use local if available
              console.log("No sector found on server");
              return false;
            }

            if (!response.ok) {
              console.error(
                "Failed to load sector from server:",
                response.status
              );
              return false;
            }

            const data = await response.json();
            const serverSector = data.sector;

            console.log("Loaded sector from server:", serverSector);

            // Create position object from server data
            selectedPosition = {
              squareX: serverSector.square_x,
              squareY: serverSector.square_y,
              innerX: serverSector.inner_x,
              innerY: serverSector.inner_y,
            };

            // Update localStorage with server data
            localStorage.setItem(sectorKey, serverSector.sector_code);
            localStorage.setItem(positionKey, JSON.stringify(selectedPosition));

            // Update UI
            updateSectorDisplay(serverSector.sector_code);

            // Disable generate button
            if (generateBtn) {
              generateBtn.disabled = true;
              generateBtn.textContent = "Sector Already Assigned";
              document.getElementById("map-instructions").textContent =
                "Your sector has been permanently assigned. You can explore the map by clicking, zooming, and panning.";
            }

            document.getElementById("sector-display").style.display = "block";
            document.getElementById("no-sector").style.display = "none";

            return true;
          } catch (error) {
            console.error("Error loading sector from server:", error);
            return false;
          }
        }

        loadUserSectorFromServer().then((serverSectorFound) => {
          if (!serverSectorFound) {
            // If no server sector, check local storage (as the code already does)
            console.log("Checking local storage for sector data");
          } else {
            // Server data loaded, now load all other players
            loadAllPlayers();
            centerOnSelectedPosition();
          }
        });

        // Create username-specific storage keys
        const sectorKey = `nebulous_sector_${username}`;
        const positionKey = `nebulous_position_${username}`;

        console.log("Using storage keys:", sectorKey, positionKey);

        const storedSector = localStorage.getItem(sectorKey);
        const storedPositionData = localStorage.getItem(positionKey);

        // Log the current sector state for this user
        console.log("Stored sector for user", username, ":", storedSector);

        // If a sector is already assigned, we'll disable generation
        if (storedSector && generateBtn) {
          console.log("Found existing sector, disabling generate button");
          generateBtn.disabled = true;
          generateBtn.textContent = "Sector Already Assigned";
          document.getElementById("map-instructions").textContent =
            "Your sector has been permanently assigned. You can explore the map by clicking, zooming, and panning.";
        }

        // Load background image
        const skyImage = new Image();
        skyImage.src = "/image/sky.png"; // Path to image
        let imageLoaded = false;

        skyImage.onload = () => {
          console.log("Background image loaded successfully");
          imageLoaded = true;

          // Restore stored position data if available
          if (storedPositionData) {
            try {
              selectedPosition = JSON.parse(storedPositionData);
              console.log(
                "Restored position for",
                username,
                ":",
                selectedPosition
              );

              // Display sector info
              updateSectorDisplay(storedSector);

              // First draw squares, then center on position
              drawAllSquares();
              setTimeout(() => centerOnSelectedPosition(), 300);
            } catch (e) {
              console.error("Error parsing stored position data:", e);
            }
          } else {
            drawAllSquares(); // Initial draw if no stored position
          }
        };

        skyImage.onerror = (e) => {
          console.error("Failed to load image /image/sky.png.", e);
          imageLoaded = false;
          drawAllSquares();
        };

        document
          .getElementById("refreshMap")
          .addEventListener("click", function () {
            loadAllPlayers();
            showSuccess("Player positions refreshed");
          });

        function drawSquare(x, y, size, isSelected = false) {
          if (isSelected) {
            // Highlight selected square if needed
          } else if (imageLoaded) {
            // Draw the image to fill the square
            ctx.drawImage(skyImage, x, y, size, size);
          } else {
            // If image isn't loaded, use default color
            ctx.fillStyle = "#222";
            ctx.fillRect(x, y, size, size);
          }
          ctx.strokeStyle = "white";
          ctx.strokeRect(x, y, size, size);
        }

        let playerPositions = [];
        let currentUserId = null;

        function drawAllSquares() {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          ctx.translate(offsetX, offsetY);
          ctx.scale(zoomLevel, zoomLevel);

          squares.forEach((square) => {
            const isSelected =
              selectedPosition &&
              square.x === selectedPosition.squareX &&
              square.y === selectedPosition.squareY;
            drawSquare(square.x, square.y, square.size, isSelected);
          });

          // Draw selected position (your own position)
          if (selectedPosition) {
            const { squareX, squareY, innerX, innerY } = selectedPosition;
            const cellSize = 20 / 10; // Adjusted cell size

            const pixelX = squareX + innerX * cellSize;
            const pixelY = squareY + innerY * cellSize;

            // Add glow effect for your marker
            ctx.shadowColor = "rgba(255, 0, 0, 0.8)";
            ctx.shadowBlur = 5;

            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(
              pixelX + 5 / zoomLevel,
              pixelY + 5 / zoomLevel,
              5 / zoomLevel,
              0,
              Math.PI * 2
            );
            ctx.fill();

            // Reset shadow
            ctx.shadowBlur = 0;

            // Add YOUR location text
            if (zoomLevel > 2) {
              ctx.fillStyle = "white";
              ctx.font = `${12 / zoomLevel}px Arial`;
              ctx.textAlign = "center";
              ctx.fillText(
                "YOU",
                pixelX + 5 / zoomLevel,
                pixelY - 5 / zoomLevel
              );
            }
          }

          // Draw other players' positions
          if (playerPositions && playerPositions.length > 0) {
            playerPositions.forEach((player) => {
              // Skip current user since we already drew it in red
              if (player.user_id === currentUserId) return;

              const pixelX = player.square_x + player.inner_x * (20 / 10);
              const pixelY = player.square_y + player.inner_y * (20 / 10);

              // Add glow effect for other players
              ctx.shadowColor = "rgba(255, 255, 0, 0.6)";
              ctx.shadowBlur = 5;

              ctx.fillStyle = "gold";
              ctx.beginPath();
              ctx.arc(
                pixelX + 5 / zoomLevel,
                pixelY + 5 / zoomLevel,
                4 / zoomLevel,
                0,
                Math.PI * 2
              );
              ctx.fill();

              // Reset shadow
              ctx.shadowBlur = 0;

              // Draw player name if zoomed in enough
              if (zoomLevel > 2) {
                ctx.fillStyle = "white";
                ctx.font = `${10 / zoomLevel}px Arial`;
                ctx.textAlign = "center";
                ctx.fillText(
                  player.username,
                  pixelX + 5 / zoomLevel,
                  pixelY - 5 / zoomLevel
                );
              }
            });
          }
        }

        loadAllPlayers();

        async function syncLocalSectorWithServer() {
          try {
            const token = localStorage.getItem("token");
            if (!token) return false;

            // Get sector data from localStorage
            const sectorKey = `nebulous_sector_${username}`;
            const positionKey = `nebulous_position_${username}`;

            const storedSector = localStorage.getItem(sectorKey);
            const storedPositionData = localStorage.getItem(positionKey);

            if (!storedSector || !storedPositionData) {
              console.log("No local sector data to sync");
              return false;
            }

            // Parse position data
            const position = JSON.parse(storedPositionData);

            console.log(
              "Syncing local sector with server:",
              storedSector,
              position
            );

            // Send data to server
            const response = await fetch("/api/sector/sync", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify({
                sector: storedSector,
                position: position,
              }),
            });

            if (!response.ok) {
              console.error(
                "Failed to sync sector with server:",
                response.status
              );
              return false;
            }

            const data = await response.json();
            console.log("Sector synced successfully:", data);
            return true;
          } catch (error) {
            console.error("Error syncing sector with server:", error);
            return false;
          }
        }

        // Call this function at startup
        document.addEventListener("DOMContentLoaded", function () {
          setTimeout(() => {
            syncLocalSectorWithServer();
          }, 1000); // Wait 1 second after page load to ensure username is available
        });

        // Add this to initializeMap, after loadUserSectorFromServer
        // Modify the existing code:
        loadUserSectorFromServer().then((serverSectorFound) => {
          if (!serverSectorFound) {
            // If no server sector, check local storage (as the code already does)
            console.log("Checking local storage for sector data");

            // If we have local data but not server data, sync it
            if (localStorage.getItem(sectorKey)) {
              syncLocalSectorWithServer();
            }
          } else {
            // Server data loaded, now load all other players
            loadAllPlayers();
            centerOnSelectedPosition();
          }
        });

        // Also add syncLocalSectorWithServer call to the refresh button handler
        document
          .getElementById("refreshMap")
          .addEventListener("click", function () {
            syncLocalSectorWithServer().then(() => {
              loadAllPlayers();
              showSuccess("Player positions refreshed");
            });
          });

        function splitAllSquares() {
          if (clickCount >= 5) return;

          const newSquares = [];
          squares.forEach((square) => {
            if (square.level >= 5) {
              newSquares.push(square);
              return;
            }

            const newSize = square.size / 2;
            const newLevel = square.level + 1;
            newSquares.push(
              { x: square.x, y: square.y, size: newSize, level: newLevel },
              {
                x: square.x + newSize,
                y: square.y,
                size: newSize,
                level: newLevel,
              },
              {
                x: square.x,
                y: square.y + newSize,
                size: newSize,
                level: newLevel,
              },
              {
                x: square.x + newSize,
                y: square.y + newSize,
                size: newSize,
                level: newLevel,
              }
            );
          });

          squares = newSquares;
          drawAllSquares();
        }

        function getPositionFormat(squareX, squareY, innerX, innerY) {
          let format = "";
          let x = squareX / 640;
          let y = squareY / 640;

          for (let level = 0; level < 4; level++) {
            let sectorLetter = "";
            if (x < 0.5 && y < 0.5) {
              sectorLetter = "A";
            } else if (x >= 0.5 && y < 0.5) {
              sectorLetter = "B";
              x -= 0.5;
            } else if (x < 0.5 && y >= 0.5) {
              sectorLetter = "C";
              y -= 0.5;
            } else {
              sectorLetter = "D";
              x -= 0.5;
              y -= 0.5;
            }
            format += sectorLetter;

            x *= 2;
            y *= 2;

            let sectorNumber = "";
            if (x < 0.5 && y < 0.5) {
              sectorNumber = "1";
            } else if (x >= 0.5 && y < 0.5) {
              sectorNumber = "2";
              x -= 0.5;
            } else if (x < 0.5 && y >= 0.5) {
              sectorNumber = "3";
              y -= 0.5;
            } else {
              sectorNumber = "4";
              x -= 0.5;
              y -= 0.5;
            }
            format += sectorNumber;

            x *= 2;
            y *= 2;
          }

          const innerPos = innerY * 10 + innerX;
          format += innerPos.toString().padStart(2, "0");

          return format;
        }

        function updateSectorDisplay(sectorCode) {
          document.getElementById("sector-code").textContent =
            "Sector: " + sectorCode;
          document.getElementById(
            "sector-description"
          ).textContent = `Your assigned sector has been plotted on the map. This location is identified as ${sectorCode}.`;

          document.getElementById("sector-display").style.display = "block";
          document.getElementById("no-sector").style.display = "none";
        }

        function selectRandomPosition() {
          console.log("Selecting random position for user:", username);

          // If a sector is already assigned, don't allow generating a new one
          if (localStorage.getItem(sectorKey)) {
            showError(
              "A sector has already been assigned to you. This cannot be changed."
            );
            return;
          }

          const gridSize = 32;
          const squareSize = 640 / gridSize;

          const randGridX = Math.floor(Math.random() * gridSize);
          const randGridY = Math.floor(Math.random() * gridSize);
          const squareX = randGridX * squareSize;
          const squareY = randGridY * squareSize;

          const innerX = Math.floor(Math.random() * 10);
          const innerY = Math.floor(Math.random() * 10);

          selectedPosition = { squareX, squareY, innerX, innerY };
          const positionFormat = getPositionFormat(
            squareX,
            squareY,
            innerX,
            innerY
          );

          console.log("Generated sector for", username, ":", positionFormat);

          // Update UI with sector info
          updateSectorDisplay(positionFormat);

          // Store the sector code AND position data in localStorage for persistence
          localStorage.setItem(sectorKey, positionFormat);
          localStorage.setItem(positionKey, JSON.stringify(selectedPosition));

          // Disable the generate button after selection
          if (generateBtn) {
            generateBtn.disabled = true;
            generateBtn.textContent = "Sector Assigned";
            document.getElementById("map-instructions").textContent =
              "Your sector has been permanently assigned. You can explore the map by clicking, zooming, and panning.";
          }

          // Send sector data to server
          try {
            const token = localStorage.getItem("token");
            fetch("/api/sector/assign", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify({
                sector: positionFormat,
                position: selectedPosition,
              }),
            })
              .then((response) => {
                if (!response.ok) {
                  console.error(
                    "Failed to save sector to server:",
                    response.status
                  );
                  // If server save fails, still show the sector locally
                }
              })
              .catch((error) => {
                console.error("Error saving sector to server:", error);
              });
          } catch (e) {
            console.error("Error preparing sector data for server:", e);
          }

          // Center the view on the selected position
          centerOnSelectedPosition();

          // Show success message
          showSuccess("Sector successfully assigned: " + positionFormat);

          // Draw everything
          loadAllPlayers();
        }
        async function loadAllPlayers() {
          try {
            const token = localStorage.getItem("token");
            if (!token) return;

            console.log("Loading all player positions...");

            // Show a loading indicator in player count
            document.getElementById("player-count").textContent = "loading...";

            const response = await fetch("/api/sectors/all", {
              headers: {
                Authorization: `Bearer ${token}`,
              },
            });

            if (!response.ok) {
              console.error("Failed to load all sectors:", response.status);
              document.getElementById("player-count").textContent = "error";
              return;
            }

            const data = await response.json();

            // Handle case where data.sectors might be empty
            if (!data.sectors || !Array.isArray(data.sectors)) {
              console.log("No sector data received from server");
              playerPositions = [];
              currentUserId = data.currentUserId;
              document.getElementById("player-count").textContent = "0";
              drawAllSquares();
              return;
            }

            playerPositions = data.sectors;
            currentUserId = data.currentUserId;

            // Update player count in the UI
            const otherPlayerCount = playerPositions.filter(
              (p) => p.user_id !== currentUserId
            ).length;
            document.getElementById("player-count").textContent =
              otherPlayerCount;

            console.log(
              `Loaded ${playerPositions.length} player positions (${otherPlayerCount} other players)`
            );

            // Log the first few entries for debugging
            if (playerPositions.length > 0) {
              console.log("Sample player data:", playerPositions.slice(0, 2));
            }

            drawAllSquares(); // Redraw with all players
          } catch (error) {
            console.error("Error loading player positions:", error);
            document.getElementById("player-count").textContent = "error";
          }
        }
        function centerOnSelectedPosition() {
          if (!selectedPosition) return;

          console.log("Centering on position:", selectedPosition);

          const { squareX, squareY } = selectedPosition;
          const canvasRect = canvas.getBoundingClientRect();

          // Center the view on the selected position
          offsetX = canvasRect.width / 2 - squareX * zoomLevel;
          offsetY = canvasRect.height / 2 - squareY * zoomLevel;

          loadAllPlayers(); // Load all players when centering
          drawAllSquares();
        }
        // Event Listeners
        canvas.addEventListener("click", () => {
          console.log("Canvas clicked, clickCount:", clickCount);
          if (clickCount < 5) {
            clickCount++;
            splitAllSquares();
          }
        });

        canvas.addEventListener("wheel", (e) => {
          e.preventDefault();

          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          const worldXBefore = (mouseX - offsetX) / zoomLevel;
          const worldYBefore = (mouseY - offsetY) / zoomLevel;

          const zoomSpeed = 0.1;
          const zoomDelta = e.deltaY < 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
          zoomLevel *= zoomDelta;

          zoomLevel = Math.max(1, Math.min(zoomLevel, 100));

          const worldXAfter = (mouseX - offsetX) / zoomLevel;
          const worldYAfter = (mouseY - offsetY) / zoomLevel;
          offsetX += (worldXAfter - worldXBefore) * zoomLevel;
          offsetY += (worldYAfter - worldYBefore) * zoomLevel;

          drawAllSquares();
        });

        canvas.addEventListener("mousedown", (e) => {
          isDragging = true;
          dragStartX = e.clientX - offsetX;
          dragStartY = e.clientY - offsetY;
        });

        canvas.addEventListener("mousemove", (e) => {
          if (isDragging) {
            offsetX = e.clientX - dragStartX;
            offsetY = e.clientY - dragStartY;
            drawAllSquares();
          }
        });

        canvas.addEventListener("mouseup", () => {
          isDragging = false;
        });

        canvas.addEventListener("mouseleave", () => {
          isDragging = false;
        });

        // Generate sector button
        if (generateBtn) {
          generateBtn.addEventListener("click", () => {
            console.log("Generate sector button clicked for user:", username);

            // Double-check if a sector already exists
            if (localStorage.getItem(sectorKey)) {
              showError(
                "A sector has already been assigned to you. This cannot be changed."
              );
              generateBtn.disabled = true;
              return;
            }

            clickCount = 5; // Reset to allow for sector generation
            selectRandomPosition();
            clickCount = 6; // Increment to prevent further automatic selection
          });
        } else {
          console.error("Generate sector button not found!");
        }

        // Check if a sector has already been generated
        if (storedSector) {
          console.log("Found stored sector for", username, ":", storedSector);
          document.getElementById("sector-code").textContent =
            "Sector: " + storedSector;
          document.getElementById(
            "sector-description"
          ).textContent = `Your assigned sector is ${storedSector}. This location is permanently assigned to you.`;

          document.getElementById("sector-display").style.display = "block";
          document.getElementById("no-sector").style.display = "none";
        }

        // Initial drawing happens after image load or in the error handler
        console.log("Map initialization complete for user:", username);
      }

      async function diagnoseSectors() {
        try {
          const token = localStorage.getItem("token");
          if (!token) {
            showError("Not logged in");
            return;
          }

          // Show loading message
          showSuccess("Running diagnostics...");

          // Call the diagnostic endpoint
          const response = await fetch("/api/sectors/diagnose", {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            showError(`Diagnostic failed: ${response.status}`);
            return;
          }

          const data = await response.json();

          // Create a diagnostic message
          let message = `
      <strong>Sector Diagnostics:</strong><br>
      Table exists: ${data.tableExists ? "Yes" : "No"}<br>
      Total sectors: ${data.sectorCount}<br>
      Errors found: ${data.errorEntries.length}<br>
      Recent entries: ${data.recentEntries.length}<br>
      <br>
      <strong>Local Storage:</strong><br>
      Username: ${username}<br>
      Sector key: ${
        localStorage.getItem(`nebulous_sector_${username}`) || "Not set"
      }<br>
      Position data: ${
        localStorage.getItem(`nebulous_position_${username}`)
          ? "Set"
          : "Not set"
      }<br>
      <br>
      <strong>Recent entries:</strong><br>
      ${data.recentEntries
        .map((entry) => `User: ${entry.username}, Sector: ${entry.sector_code}`)
        .join("<br>")}
    `;

          // Display it
          const diagElement = document.createElement("div");
          diagElement.className = "diagnostic-popup";
          diagElement.innerHTML = `
      <div class="diagnostic-content">
        <h3>Sector Diagnostics</h3>
        <div class="diagnostic-info">${message}</div>
        <button id="closeDiag" class="btn btn-primary">Close</button>
        <button id="forceSyncDiag" class="btn btn-warning">Force Sync</button>
      </div>
    `;

          document.body.appendChild(diagElement);

          // Add event listeners to buttons
          document.getElementById("closeDiag").addEventListener("click", () => {
            document.body.removeChild(diagElement);
          });

          document
            .getElementById("forceSyncDiag")
            .addEventListener("click", async () => {
              document.body.removeChild(diagElement);
              await syncLocalSectorWithServer();
              loadAllPlayers();
              showSuccess("Force sync completed");
            });

          // Add some basic styling
          const style = document.createElement("style");
          style.textContent = `
      .diagnostic-popup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      .diagnostic-content {
        background-color: #222;
        border: 1px solid #444;
        border-radius: 5px;
        padding: 20px;
        max-width: 80%;
        max-height: 80%;
        overflow-y: auto;
      }
      .diagnostic-info {
        margin: 15px 0;
        white-space: pre-line;
        text-align: left;
      }
    `;
          document.head.appendChild(style);
        } catch (error) {
          console.error("Error running diagnostics:", error);
          showError("Diagnostic error: " + error.message);
        }
      }

      // Add event listener for the diagnose button
      document
        .getElementById("diagnoseSectors")
        .addEventListener("click", diagnoseSectors);
    </script>
  </body>
</html>
