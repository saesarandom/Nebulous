<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nebulous - Map</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link href="/styles.css" rel="stylesheet" />
    <link href="/timeElapsed.css" rel="stylesheet" />
    <style>
      .map-container {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 20px 0;
        position: relative;
        z-index: 1;
      }

      canvas {
        border: 1px solid #333;
        background-color: #111;
        cursor: grab;
        max-width: 100%;
        height: auto;
      }

      canvas:active {
        cursor: grabbing;
      }

      .sector-info {
        background-color: rgba(20, 20, 30, 0.7);
        border-radius: 10px;
        border: 1px solid #333;
        padding: 20px;
        margin-top: 20px;
      }

      .sector-code {
        font-family: "Courier New", monospace;
        font-size: 20px;
        font-weight: bold;
        color: #4fd1c5;
        text-align: center;
        margin: 10px 0;
      }

      .btn-generate {
        background-color: #198754;
        border-color: #157347;
        margin-bottom: 15px;
      }

      .btn-generate:disabled {
        background-color: #597a68;
        border-color: #495f53;
        cursor: not-allowed;
        opacity: 0.6;
      }

      /* Override any canvas-related styles */
      body {
        display: block !important;
        justify-content: normal !important;
        align-items: normal !important;
        height: auto !important;
      }
    </style>
  </head>
  <body>
    <div class="dashboard-container">
      <!-- Left Sidebar Navigation -->
      <div class="sidebar">
        <a href="dashboard.html" class="nav-btn">Dashboard</a>
        <a href="planet.html" class="nav-btn">Planet</a>
        <a href="mecha.html" class="nav-btn">Mecha</a>
        <a href="buildings.html" class="nav-btn">Buildings</a>
        <a href="extraction.html" class="nav-btn">Extraction</a>
        <a href="research.html" class="nav-btn">Research</a>
        <a href="events.html" class="nav-btn">Events</a>
        <a href="slots.html" class="nav-btn">Slots</a>
        <a href="guide.html" class="nav-btn">Guide</a>
        <a href="map.html" class="nav-btn active">Map</a>
      </div>

      <!-- Main Content Area -->
      <div class="flex-grow-1 d-flex flex-column">
        <!-- Header with user info and logout -->
        <div class="header">
          <h3>Nebulous - Map</h3>
          <div class="d-flex align-items-center">
            <div class="user-info">
              Welcome, <span id="username">User</span>
            </div>
            <button id="logoutBtn" class="logout-btn">Logout</button>
          </div>
        </div>

        <!-- Main content -->
        <div class="main-content">
          <h2 class="page-title">Sector Map</h2>

          <!-- Map Controls -->
          <div class="row mb-4">
            <div class="col-md-12 text-center">
              <button id="generateSector" class="btn btn-success btn-generate">
                Generate Random Sector
              </button>
              <p class="text-muted" id="map-instructions">
                Click on the map to zoom in and reveal sector divisions. Use
                mouse wheel to zoom, drag to pan.
              </p>
            </div>
          </div>

          <!-- Map Canvas -->
          <div class="map-container">
            <canvas id="mapCanvas" width="640" height="640"></canvas>
          </div>

          <!-- Sector Information -->
          <div class="row mt-4">
            <div class="col-md-12">
              <div class="sector-info">
                <h4 class="text-center">Sector Information</h4>
                <div id="sector-display" style="display: none">
                  <p class="sector-code" id="sector-code">Not yet generated</p>
                  <p class="text-center" id="sector-description">
                    Generate a sector to begin exploration.
                  </p>
                </div>
                <div id="no-sector" class="text-center">
                  <p>
                    No sector assigned. Click the Generate button to randomly
                    assign a sector.
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Error and success message containers -->
    <div
      id="error-message"
      class="alert alert-danger"
      style="
        display: none;
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
      "
    ></div>
    <div
      id="success-message"
      class="alert alert-success"
      style="
        display: none;
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
      "
    ></div>

    <!-- Shared JavaScript -->
    <script src="/js/script.js"></script>
    <script src="/js/timeElapsed.js"></script>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        console.log("Page loaded - initializing map");

        // Check if user is logged in (token exists)
        const token = localStorage.getItem("token");
        if (!token) {
          window.location.href = "login.html";
          return;
        }

        // Fetch user data and initialize map once we have the username
        fetchUserDataForMap();
      });

      // Special version of fetchUserData that initializes the map afterward
      async function fetchUserDataForMap() {
        try {
          const token = localStorage.getItem("token");
          const response = await fetch("/api/user", {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (response.ok) {
            const userData = await response.json();
            const usernameElement = document.getElementById("username");
            if (usernameElement) {
              usernameElement.textContent = userData.username;
            }

            // Initialize map after we have the username
            initializeMap();
          } else {
            // If token is invalid, redirect to login
            localStorage.removeItem("token");
            window.location.href = "login.html";
          }
        } catch (error) {
          console.error("Error fetching user data:", error);
          showError("Error loading user data. Please try refreshing the page.");
        }
      }

      function showError(message) {
        const errorDiv = document.getElementById("error-message");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";

        setTimeout(() => {
          errorDiv.style.display = "none";
        }, 5000);
      }

      function showSuccess(message) {
        const successDiv = document.getElementById("success-message");
        successDiv.textContent = message;
        successDiv.style.display = "block";

        setTimeout(() => {
          successDiv.style.display = "none";
        }, 5000);
      }

      function initializeMap() {
        console.log("Initializing map...");

        const canvas = document.getElementById("mapCanvas");
        const ctx = canvas.getContext("2d");
        const generateBtn = document.getElementById("generateSector");
        const username = document.getElementById("username").textContent;

        if (!username || username === "User") {
          console.error("Username not available yet, retrying in 1 second");
          setTimeout(initializeMap, 1000);
          return;
        }

        console.log("Map initialization for user:", username);

        let squares = [{ x: 0, y: 0, size: 640, level: 0 }];
        let clickCount = 0;
        let selectedPosition = null;

        // Variables for zoom and pan
        let zoomLevel = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        // Create username-specific storage keys
        const sectorKey = `nebulous_sector_${username}`;
        const positionKey = `nebulous_position_${username}`;

        console.log("Using storage keys:", sectorKey, positionKey);

        const storedSector = localStorage.getItem(sectorKey);
        const storedPositionData = localStorage.getItem(positionKey);

        // Log the current sector state for this user
        console.log("Stored sector for user", username, ":", storedSector);

        // If a sector is already assigned, we'll disable generation
        if (storedSector && generateBtn) {
          console.log("Found existing sector, disabling generate button");
          generateBtn.disabled = true;
          generateBtn.textContent = "Sector Already Assigned";
          document.getElementById("map-instructions").textContent =
            "Your sector has been permanently assigned. You can explore the map by clicking, zooming, and panning.";
        }

        // Load background image
        const skyImage = new Image();
        skyImage.src = "/image/sky.png"; // Path to image
        let imageLoaded = false;

        skyImage.onload = () => {
          console.log("Background image loaded successfully");
          imageLoaded = true;

          // Restore stored position data if available
          if (storedPositionData) {
            try {
              selectedPosition = JSON.parse(storedPositionData);
              console.log(
                "Restored position for",
                username,
                ":",
                selectedPosition
              );

              // Display sector info
              updateSectorDisplay(storedSector);

              // First draw squares, then center on position
              drawAllSquares();
              setTimeout(() => centerOnSelectedPosition(), 300);
            } catch (e) {
              console.error("Error parsing stored position data:", e);
            }
          } else {
            drawAllSquares(); // Initial draw if no stored position
          }
        };

        skyImage.onerror = (e) => {
          console.error("Failed to load image /image/sky.png.", e);
          imageLoaded = false;
          drawAllSquares();
        };

        function drawSquare(x, y, size, isSelected = false) {
          if (isSelected) {
            // Highlight selected square if needed
          } else if (imageLoaded) {
            // Draw the image to fill the square
            ctx.drawImage(skyImage, x, y, size, size);
          } else {
            // If image isn't loaded, use default color
            ctx.fillStyle = "#222";
            ctx.fillRect(x, y, size, size);
          }
          ctx.strokeStyle = "white";
          ctx.strokeRect(x, y, size, size);
        }

        function drawAllSquares() {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          ctx.translate(offsetX, offsetY);
          ctx.scale(zoomLevel, zoomLevel);

          squares.forEach((square) => {
            const isSelected =
              selectedPosition &&
              square.x === selectedPosition.squareX &&
              square.y === selectedPosition.squareY;
            drawSquare(square.x, square.y, square.size, isSelected);
          });

          if (selectedPosition) {
            const { squareX, squareY, innerX, innerY } = selectedPosition;
            const squareSize = 20;
            const cellSize = squareSize / 10;

            const pixelX = squareX + innerX * cellSize;
            const pixelY = squareY + innerY * cellSize;

            ctx.fillStyle = "red";
            ctx.fillRect(pixelX, pixelY, 10 / zoomLevel, 10 / zoomLevel);

            console.log("Drew marker at:", pixelX, pixelY);
          }
        }

        function splitAllSquares() {
          if (clickCount >= 5) return;

          const newSquares = [];
          squares.forEach((square) => {
            if (square.level >= 5) {
              newSquares.push(square);
              return;
            }

            const newSize = square.size / 2;
            const newLevel = square.level + 1;
            newSquares.push(
              { x: square.x, y: square.y, size: newSize, level: newLevel },
              {
                x: square.x + newSize,
                y: square.y,
                size: newSize,
                level: newLevel,
              },
              {
                x: square.x,
                y: square.y + newSize,
                size: newSize,
                level: newLevel,
              },
              {
                x: square.x + newSize,
                y: square.y + newSize,
                size: newSize,
                level: newLevel,
              }
            );
          });

          squares = newSquares;
          drawAllSquares();
        }

        function getPositionFormat(squareX, squareY, innerX, innerY) {
          let format = "";
          let x = squareX / 640;
          let y = squareY / 640;

          for (let level = 0; level < 4; level++) {
            let sectorLetter = "";
            if (x < 0.5 && y < 0.5) {
              sectorLetter = "A";
            } else if (x >= 0.5 && y < 0.5) {
              sectorLetter = "B";
              x -= 0.5;
            } else if (x < 0.5 && y >= 0.5) {
              sectorLetter = "C";
              y -= 0.5;
            } else {
              sectorLetter = "D";
              x -= 0.5;
              y -= 0.5;
            }
            format += sectorLetter;

            x *= 2;
            y *= 2;

            let sectorNumber = "";
            if (x < 0.5 && y < 0.5) {
              sectorNumber = "1";
            } else if (x >= 0.5 && y < 0.5) {
              sectorNumber = "2";
              x -= 0.5;
            } else if (x < 0.5 && y >= 0.5) {
              sectorNumber = "3";
              y -= 0.5;
            } else {
              sectorNumber = "4";
              x -= 0.5;
              y -= 0.5;
            }
            format += sectorNumber;

            x *= 2;
            y *= 2;
          }

          const innerPos = innerY * 10 + innerX;
          format += innerPos.toString().padStart(2, "0");

          return format;
        }

        function updateSectorDisplay(sectorCode) {
          document.getElementById("sector-code").textContent =
            "Sector: " + sectorCode;
          document.getElementById(
            "sector-description"
          ).textContent = `Your assigned sector has been plotted on the map. This location is identified as ${sectorCode}.`;

          document.getElementById("sector-display").style.display = "block";
          document.getElementById("no-sector").style.display = "none";
        }

        function selectRandomPosition() {
          console.log("Selecting random position for user:", username);

          // If a sector is already assigned, don't allow generating a new one
          if (localStorage.getItem(sectorKey)) {
            showError(
              "A sector has already been assigned to you. This cannot be changed."
            );
            return;
          }

          const gridSize = 32;
          const squareSize = 640 / gridSize;

          const randGridX = Math.floor(Math.random() * gridSize);
          const randGridY = Math.floor(Math.random() * gridSize);
          const squareX = randGridX * squareSize;
          const squareY = randGridY * squareSize;

          const innerX = Math.floor(Math.random() * 10);
          const innerY = Math.floor(Math.random() * 10);

          selectedPosition = { squareX, squareY, innerX, innerY };
          const positionFormat = getPositionFormat(
            squareX,
            squareY,
            innerX,
            innerY
          );

          console.log("Generated sector for", username, ":", positionFormat);

          // Update UI with sector info
          updateSectorDisplay(positionFormat);

          // Store the sector code AND position data in localStorage for persistence
          // Use username-specific keys
          localStorage.setItem(sectorKey, positionFormat);
          localStorage.setItem(positionKey, JSON.stringify(selectedPosition));

          // Disable the generate button after selection
          if (generateBtn) {
            generateBtn.disabled = true;
            generateBtn.textContent = "Sector Assigned";
            document.getElementById("map-instructions").textContent =
              "Your sector has been permanently assigned. You can explore the map by clicking, zooming, and panning.";
          }

          // Send sector data to server (you'll implement this API later)
          try {
            // This is where you would send the data to your Neon database
            // For now, we'll just log it
            console.log(
              "Would save sector",
              positionFormat,
              "for user",
              username,
              "to database"
            );

            // Future implementation example:
            /*
            fetch('/api/sector/assign', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('token')}`
              },
              body: JSON.stringify({
                username: username,
                sector: positionFormat,
                position: selectedPosition
              })
            });
            */
          } catch (e) {
            console.error("Error saving sector to server:", e);
          }

          // Center the view on the selected position
          centerOnSelectedPosition();

          // Show success message
          showSuccess("Sector successfully assigned: " + positionFormat);

          // Draw everything
          drawAllSquares();
        }

        function centerOnSelectedPosition() {
          if (!selectedPosition) return;

          console.log("Centering on position:", selectedPosition);

          const { squareX, squareY } = selectedPosition;
          const canvasRect = canvas.getBoundingClientRect();

          // Center the view on the selected position
          offsetX = canvasRect.width / 2 - squareX * zoomLevel;
          offsetY = canvasRect.height / 2 - squareY * zoomLevel;

          drawAllSquares();
        }

        // Event Listeners
        canvas.addEventListener("click", () => {
          console.log("Canvas clicked, clickCount:", clickCount);
          if (clickCount < 5) {
            clickCount++;
            splitAllSquares();
          }
        });

        canvas.addEventListener("wheel", (e) => {
          e.preventDefault();

          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          const worldXBefore = (mouseX - offsetX) / zoomLevel;
          const worldYBefore = (mouseY - offsetY) / zoomLevel;

          const zoomSpeed = 0.1;
          const zoomDelta = e.deltaY < 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
          zoomLevel *= zoomDelta;

          zoomLevel = Math.max(1, Math.min(zoomLevel, 100));

          const worldXAfter = (mouseX - offsetX) / zoomLevel;
          const worldYAfter = (mouseY - offsetY) / zoomLevel;
          offsetX += (worldXAfter - worldXBefore) * zoomLevel;
          offsetY += (worldYAfter - worldYBefore) * zoomLevel;

          drawAllSquares();
        });

        canvas.addEventListener("mousedown", (e) => {
          isDragging = true;
          dragStartX = e.clientX - offsetX;
          dragStartY = e.clientY - offsetY;
        });

        canvas.addEventListener("mousemove", (e) => {
          if (isDragging) {
            offsetX = e.clientX - dragStartX;
            offsetY = e.clientY - dragStartY;
            drawAllSquares();
          }
        });

        canvas.addEventListener("mouseup", () => {
          isDragging = false;
        });

        canvas.addEventListener("mouseleave", () => {
          isDragging = false;
        });

        // Generate sector button
        if (generateBtn) {
          generateBtn.addEventListener("click", () => {
            console.log("Generate sector button clicked for user:", username);

            // Double-check if a sector already exists
            if (localStorage.getItem(sectorKey)) {
              showError(
                "A sector has already been assigned to you. This cannot be changed."
              );
              generateBtn.disabled = true;
              return;
            }

            clickCount = 5; // Reset to allow for sector generation
            selectRandomPosition();
            clickCount = 6; // Increment to prevent further automatic selection
          });
        } else {
          console.error("Generate sector button not found!");
        }

        // Check if a sector has already been generated
        if (storedSector) {
          console.log("Found stored sector for", username, ":", storedSector);
          document.getElementById("sector-code").textContent =
            "Sector: " + storedSector;
          document.getElementById(
            "sector-description"
          ).textContent = `Your assigned sector is ${storedSector}. This location is permanently assigned to you.`;

          document.getElementById("sector-display").style.display = "block";
          document.getElementById("no-sector").style.display = "none";
        }

        // Initial drawing happens after image load or in the error handler
        console.log("Map initialization complete for user:", username);
      }
    </script>
  </body>
</html>
