<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nebulous - Map</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link href="/styles.css" rel="stylesheet" />
    <link href="/timeElapsed.css" rel="stylesheet" />
    <style>
      .map-container {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 20px 0;
        position: relative;
        z-index: 1;
      }

      canvas {
        border: 1px solid #333;
        background-color: #111;
        cursor: grab;
        max-width: 100%;
        height: auto;
      }

      canvas:active {
        cursor: grabbing;
      }

      .sector-info {
        background-color: rgba(20, 20, 30, 0.7);
        border-radius: 10px;
        border: 1px solid #333;
        padding: 20px;
        margin-top: 20px;
      }

      .sector-code {
        font-family: "Courier New", monospace;
        font-size: 20px;
        font-weight: bold;
        color: #4fd1c5;
        text-align: center;
        margin: 10px 0;
      }

      .btn-generate {
        background-color: #198754;
        border-color: #157347;
        margin-bottom: 15px;
      }

      .btn-generate:disabled {
        background-color: #597a68;
        border-color: #495f53;
        cursor: not-allowed;
        opacity: 0.6;
      }

      body {
        display: block !important;
        justify-content: normal !important;
        align-items: normal !important;
        height: auto !important;
      }

      .ml-2 {
        margin-left: 0.5rem;
      }

      .player-marker {
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.6;
        }
      }

      .player-label {
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        pointer-events: none;
      }

/* Add these styles to your map.html <style> section */
/* Distance calculator styling */
.distance-calculator-tabs .nav-tabs {
  border-bottom-color: #444;
}

.distance-calculator-tabs .nav-link {
  color: #aaa;
  background-color: #222;
  border-color: #333 #333 #444;
  margin-right: 5px;
}

.distance-calculator-tabs .nav-link:hover {
  color: #fff;
  background-color: #333;
  border-color: #444 #444 #444;
}

.distance-calculator-tabs .nav-link.active {
  color: #4fd1c5;
  background-color: #333;
  border-color: #444 #444 #333;
}

.tab-content {
  padding: 15px;
  background-color: #222;
  border: 1px solid #444;
  border-top: none;
  border-radius: 0 0 5px 5px;
}

#distance-result, #player-distances-result {
  background-color: rgba(30, 30, 40, 0.7);
  border-radius: 5px;
  padding: 15px;
  margin-top: 15px;
}

/* Highlight travel times with different colors */
#travel-warp9 {
  color: #dc3545; /* Red for slowest */
}

#travel-warp-max {
  color: #ffc107; /* Yellow for medium */
}

#travel-quantum {
  color: #0dcaf0; /* Cyan for faster */
}

#travel-transwarp {
  color: #20c997; /* Teal for fastest */
}

/* Table styles */
.table-dark {
  background-color: #222;
}

.table-dark thead th {
  background-color: #111;
  border-color: #444;
}

.table-dark tbody td {
  border-color: #333;
}

/* Input styling */
.form-control {
  background-color: #333;
  border-color: #444;
  color: #fff;
}

.form-control:focus {
  background-color: #444;
  color: #fff;
  border-color: #4fd1c5;
  box-shadow: 0 0 0 0.25rem rgba(79, 209, 197, 0.25);
}

.form-label {
  color: #ccc;
  font-size: 0.875rem;
}


#use-my-position {
  background-color: #6c757d;
  border-color: #6c757d;
}

#use-my-position:hover {
  background-color: #5c636a;
  border-color: #565e64;
}

#calculate-distance {
  background-color: #198754;
  border-color: #157347;
}

#calculate-distance:hover {
  background-color: #157347;
  border-color: #146c43;
}

#get-player-distances {
  background-color: #0d6efd;
  border-color: #0a58ca;
}

#get-player-distances:hover {
  background-color: #0a58ca;
  border-color: #0a53be;
}


.g-2 > * {
  padding: 0.25rem;
}

.mb-1 {
  margin-bottom: 0.25rem !important;
}

.mb-2 {
  margin-bottom: 0.5rem !important;
}

.mb-3 {
  margin-bottom: 1rem !important;
}

.mt-2 {
  margin-top: 0.5rem !important;
}

.mt-3 {
  margin-top: 1rem !important;
}

.mt-4 {
  margin-top: 1.5rem !important;
}
    </style>
    <script src="mapDistances.js"></script>
  </head>
  <body>
    <div class="dashboard-container">
      <div class="sidebar">
        <a href="dashboard.html" class="nav-btn">Dashboard</a>
        <a href="planet.html" class="nav-btn">Planet</a>
        <a href="mecha.html" class="nav-btn">Mecha</a>
        <a href="buildings.html" class="nav-btn">Buildings</a>
        <a href="extraction.html" class="nav-btn">Extraction</a>
        <a href="research.html" class="nav-btn">Research</a>
        <a href="events.html" class="nav-btn">Events</a>
        <a href="slots.html" class="nav-btn">Slots</a>
        <a href="guide.html" class="nav-btn">Guide</a>
        <a href="map.html" class="nav-btn active">Map</a>
      </div>
     
      <!-- Main Content Area -->
      <div class="flex-grow-1 d-flex flex-column">
        <!-- Header with user info and logout -->
        <div class="header">
          <h3>Nebulous - Map</h3>
          <div class="d-flex align-items-center">
            <div class="user-info">
              Welcome, <span id="username">User</span>
            </div>
            <button id="logoutBtn" class="logout-btn">Logout</button>
          </div>
        </div>

        <!-- Main content -->
        <div class="main-content">
          <h2 class="page-title">Sector Map</h2>

          <!-- Map Controls -->
          <div class="row mb-4">
            <div class="col-md-12 text-center">
              <button id="generateSector" class="btn btn-success btn-generate">
                Generate Random Sector
              </button>
              <button id="refreshMap" class="btn btn-primary ml-2">
                Refresh Player Positions
              </button>
              <button id="diagnoseSectors" class="btn btn-warning ml-2">
                Diagnose Sectors
              </button>

              <p class="text-muted" id="map-instructions">
                Click on the map to zoom in and reveal sector divisions. Use
                mouse wheel to zoom, drag to pan.
              </p>
            </div>
          </div>

          <!-- Map Canvas -->
          <div class="map-container">
            <canvas id="mapCanvas" width="640" height="640"></canvas>
          </div>

          <!-- Sector Information -->
          <div class="row mt-4">
            <div class="col-md-12">
              <div class="sector-info">
                <h4 class="text-center">Sector Information</h4>
                <div id="sector-display" style="display: none">
                  <p class="sector-code" id="sector-code">Not yet generated</p>
                  <p class="text-center" id="sector-description">
                    Generate a sector to begin exploration.
                  </p>

                  <p class="text-center mt-3">
                    <span id="player-count">0</span> other players detected in
                    universe.
                    <span class="text-muted"
                      >(Your position shown in red, others in yellow)</span
                    >
                  </p>
                </div>
                <div id="no-sector" class="text-center">
                  <p>
                    No sector assigned. Click the Generate button to randomly
                    assign a sector.
                  </p>
                </div>
                <div class="row mt-4">
                  <div class="col-md-12">
                    <div class="sector-info">
                      <h4 class="text-center">Distance Calculator</h4>
                      
                      <div class="distance-calculator-tabs mb-3">
                        <ul class="nav nav-tabs" id="distanceCalculatorTabs" role="tablist">
                          <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="custom-tab" data-bs-toggle="tab" data-bs-target="#custom-coords" type="button" role="tab" aria-controls="custom-coords" aria-selected="true">Custom Coordinates</button>
                          </li>
                          <li class="nav-item" role="presentation">
                            <button class="nav-link" id="players-tab" data-bs-toggle="tab" data-bs-target="#player-distances" type="button" role="tab" aria-controls="player-distances" aria-selected="false">Player Distances</button>
                          </li>
                        </ul>
                      </div>
                      
                      <div class="tab-content" id="distanceCalculatorTabContent">
                        <!-- Custom Coordinates Calculator -->
                        <div class="tab-pane fade show active" id="custom-coords" role="tabpanel" aria-labelledby="custom-tab">
                          <div class="row mb-3">
                            <div class="col-md-6">
                              <h5 class="text-center">Position 1</h5>
                              <div class="row g-2">
                                <div class="col-6">
                                  <label class="form-label">Square X</label>
                                  <input type="number" class="form-control" id="pos1-square-x" value="260">
                                </div>
                                <div class="col-6">
                                  <label class="form-label">Square Y</label>
                                  <input type="number" class="form-control" id="pos1-square-y" value="20">
                                </div>
                                <div class="col-6">
                                  <label class="form-label">Inner X (0-9)</label>
                                  <input type="number" class="form-control" id="pos1-inner-x" value="6" min="0" max="9">
                                </div>
                                <div class="col-6">
                                  <label class="form-label">Inner Y (0-9)</label>
                                  <input type="number" class="form-control" id="pos1-inner-y" value="6" min="0" max="9">
                                </div>
                              </div>
                              <div class="mt-2">
                                <button class="btn btn-sm btn-primary" id="use-my-position">Use My Position</button>
                              </div>
                            </div>
                            
                            <div class="col-md-6">
                              <h5 class="text-center">Position 2</h5>
                              <div class="row g-2">
                                <div class="col-6">
                                  <label class="form-label">Square X</label>
                                  <input type="number" class="form-control" id="pos2-square-x" value="220">
                                </div>
                                <div class="col-6">
                                  <label class="form-label">Square Y</label>
                                  <input type="number" class="form-control" id="pos2-square-y" value="100">
                                </div>
                                <div class="col-6">
                                  <label class="form-label">Inner X (0-9)</label>
                                  <input type="number" class="form-control" id="pos2-inner-x" value="3" min="0" max="9">
                                </div>
                                <div class="col-6">
                                  <label class="form-label">Inner Y (0-9)</label>
                                  <input type="number" class="form-control" id="pos2-inner-y" value="6" min="0" max="9">
                                </div>
                              </div>
                            </div>
                          </div>
                          
                          <div class="text-center mb-3">
                            <button class="btn btn-success" id="calculate-distance">Calculate Distance</button>
                          </div>
                          
                          <div id="distance-result" style="display: none;">
                            <hr>
                            <h5 class="text-center">Distance Results</h5>
                            <div class="row">
                              <div class="col-md-6">
                                <div class="mb-2">
                                  <strong>Grid Distance:</strong> <span id="grid-distance"></span>
                                </div>
                                <div class="mb-2">
                                  <strong>Distance:</strong> <span id="light-years-distance"></span>
                                </div>
                                <div class="mb-2">
                                  <strong>Percentage of Universe:</strong> <span id="universe-percentage"></span>%
                                </div>
                              </div>
                              <div class="col-md-6">
                                <h6>Travel Time Estimates:</h6>
                                <div class="mb-1">
                                  <small>Warp Factor 9:</small> <span id="travel-warp9"></span>
                                </div>
                                <div class="mb-1">
                                  <small>Maximum Warp:</small> <span id="travel-warp-max"></span>
                                </div>
                                <div class="mb-1">
                                  <small>Quantum Slipstream:</small> <span id="travel-quantum"></span>
                                </div>
                                <div class="mb-1">
                                  <small>Transwarp Conduit:</small> <span id="travel-transwarp"></span>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                        
                        <!-- Player Distances Tab -->
                        <div class="tab-pane fade" id="player-distances" role="tabpanel" aria-labelledby="players-tab">
                          <div class="text-center mb-3">
                            <p class="mt-2">Click the button below to calculate distances to other players in the universe:</p>
                            <button class="btn btn-primary" id="get-player-distances">
                              Calculate Player Distances
                            </button>
                          </div>
                          
                          <div id="player-distances-result" style="display: none;">
                            <hr>
                            <h5 class="text-center">Distance to Other Players</h5>
                            <p class="text-center text-muted small">From your sector: <span id="your-sector-code">Unknown</span></p>
                            
                            <div class="table-responsive">
                              <table class="table table-dark table-hover">
                                <thead>
                                  <tr>
                                    <th>Player</th>
                                    <th>Sector</th>
                                    <th>Distance</th>
                                    <th>Travel Time</th>
                                  </tr>
                                </thead>
                                <tbody id="player-distances-table">
                                  <!-- Will be populated by JavaScript -->
                                </tbody>
                              </table>
                            </div>
                          </div>
                          
                          <div id="no-players-message" style="display: none;">
                            <div class="alert alert-info">
                              No other players found in the universe.
                            </div>
                          </div>
                        </div>


    <!-- Error and success message containers -->
    <div
      id="error-message"
      class="alert alert-danger"
      style="
        display: none;
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
      "
    ></div>
    <div
      id="success-message"
      class="alert alert-success"
      style="
        display: none;
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
      "
    ></div>

    <!-- Shared JavaScript -->
    <script src="/js/script.js"></script>
    <script src="/js/timeElapsed.js"></script>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        console.log("Page loaded - initializing map");

        // Check if user is logged in (token exists)
        const token = localStorage.getItem("token");
        if (!token) {
          window.location.href = "login.html";
          return;
        }

        // Fetch user data and initialize map once we have the username
        fetchUserDataForMap();
      });

      // Special version of fetchUserData that initializes the map afterward
      async function fetchUserDataForMap() {
        try {
          const token = localStorage.getItem("token");
          const response = await fetch("/api/user", {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (response.ok) {
            const userData = await response.json();
            const usernameElement = document.getElementById("username");
            if (usernameElement) {
              usernameElement.textContent = userData.username;
            }

            // Initialize map after we have the username
            initializeMap();
          } else {
            // If token is invalid, redirect to login
            localStorage.removeItem("token");
            window.location.href = "login.html";
          }
        } catch (error) {
          console.error("Error fetching user data:", error);
          showError("Error loading user data. Please try refreshing the page.");
        }
      }

      function showError(message) {
        const errorDiv = document.getElementById("error-message");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";

        setTimeout(() => {
          errorDiv.style.display = "none";
        }, 5000);
      }

      function showSuccess(message) {
        const successDiv = document.getElementById("success-message");
        successDiv.textContent = message;
        successDiv.style.display = "block";

        setTimeout(() => {
          successDiv.style.display = "none";
        }, 5000);
      }

      function initializeMap() {
        console.log("Initializing map...");

        const canvas = document.getElementById("mapCanvas");
        const ctx = canvas.getContext("2d");
        const generateBtn = document.getElementById("generateSector");
        const username = document.getElementById("username").textContent;

        if (!username || username === "User") {
          console.error("Username not available yet, retrying in 1 second");
          setTimeout(initializeMap, 1000);
          return;
        }

        console.log("Map initialization for user:", username);

        let squares = [{ x: 0, y: 0, size: 640, level: 0 }];
        let clickCount = 0;
        let selectedPosition = null;

        // Variables for zoom and pan
        let zoomLevel = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        async function loadUserSectorFromServer() {
          try {
            const token = localStorage.getItem("token");
            if (!token) return;

            const response = await fetch("/api/sector", {
              headers: {
                Authorization: `Bearer ${token}`,
              },
            });

            if (response.status === 404) {
              // No sector found on server, use local if available
              console.log("No sector found on server");
              return false;
            }

            if (!response.ok) {
              console.error(
                "Failed to load sector from server:",
                response.status
              );
              return false;
            }

            const data = await response.json();
            const serverSector = data.sector;

            console.log("Loaded sector from server:", serverSector);

            // Create position object from server data
            selectedPosition = {
              squareX: serverSector.square_x,
              squareY: serverSector.square_y,
              innerX: serverSector.inner_x,
              innerY: serverSector.inner_y,
            };

            // Update localStorage with server data
            localStorage.setItem(sectorKey, serverSector.sector_code);
            localStorage.setItem(positionKey, JSON.stringify(selectedPosition));

            // Update UI
            updateSectorDisplay(serverSector.sector_code);

            // Disable generate button
            if (generateBtn) {
              generateBtn.disabled = true;
              generateBtn.textContent = "Sector Already Assigned";
              document.getElementById("map-instructions").textContent =
                "Your sector has been permanently assigned. You can explore the map by clicking, zooming, and panning.";
            }

            document.getElementById("sector-display").style.display = "block";
            document.getElementById("no-sector").style.display = "none";

            return true;
          } catch (error) {
            console.error("Error loading sector from server:", error);
            return false;
          }
        }

        loadUserSectorFromServer().then((serverSectorFound) => {
          if (!serverSectorFound) {
            // If no server sector, check local storage (as the code already does)
            console.log("Checking local storage for sector data");
          } else {
            // Server data loaded, now load all other players
            loadAllPlayers();
            centerOnSelectedPosition();
          }
        });

        // Create username-specific storage keys
        const sectorKey = `nebulous_sector_${username}`;
        const positionKey = `nebulous_position_${username}`;

        console.log("Using storage keys:", sectorKey, positionKey);

        const storedSector = localStorage.getItem(sectorKey);
        const storedPositionData = localStorage.getItem(positionKey);

        // Log the current sector state for this user
        console.log("Stored sector for user", username, ":", storedSector);

        // If a sector is already assigned, we'll disable generation
        if (storedSector && generateBtn) {
          console.log("Found existing sector, disabling generate button");
          generateBtn.disabled = true;
          generateBtn.textContent = "Sector Already Assigned";
          document.getElementById("map-instructions").textContent =
            "Your sector has been permanently assigned. You can explore the map by clicking, zooming, and panning.";
        }

        // Load background image
        const skyImage = new Image();
        skyImage.src = "/image/sky.png"; // Path to image
        let imageLoaded = false;

        skyImage.onload = () => {
          console.log("Background image loaded successfully");
          imageLoaded = true;

          // Restore stored position data if available
          if (storedPositionData) {
            try {
              selectedPosition = JSON.parse(storedPositionData);
              console.log(
                "Restored position for",
                username,
                ":",
                selectedPosition
              );

              // Display sector info
              updateSectorDisplay(storedSector);

              // First draw squares, then center on position
              drawAllSquares();
              setTimeout(() => centerOnSelectedPosition(), 300);
            } catch (e) {
              console.error("Error parsing stored position data:", e);
            }
          } else {
            drawAllSquares(); // Initial draw if no stored position
          }
        };

        skyImage.onerror = (e) => {
          console.error("Failed to load image /image/sky.png.", e);
          imageLoaded = false;
          drawAllSquares();
        };

        document
          .getElementById("refreshMap")
          .addEventListener("click", function () {
            loadAllPlayers();
            showSuccess("Player positions refreshed");
          });

        function drawSquare(x, y, size, isSelected = false) {
          if (isSelected) {
            // Highlight selected square if needed
          } else if (imageLoaded) {
            // Draw the image to fill the square
            ctx.drawImage(skyImage, x, y, size, size);
          } else {
            // If image isn't loaded, use default color
            ctx.fillStyle = "#222";
            ctx.fillRect(x, y, size, size);
          }
          ctx.strokeStyle = "white";
          ctx.strokeRect(x, y, size, size);
        }

        let playerPositions = [];
        let currentUserId = null;

        function drawAllSquares() {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          ctx.translate(offsetX, offsetY);
          ctx.scale(zoomLevel, zoomLevel);

          squares.forEach((square) => {
            const isSelected =
              selectedPosition &&
              square.x === selectedPosition.squareX &&
              square.y === selectedPosition.squareY;
            drawSquare(square.x, square.y, square.size, isSelected);
          });

          // Draw selected position (your own position)
          if (selectedPosition) {
            const { squareX, squareY, innerX, innerY } = selectedPosition;
            const cellSize = 20 / 10; // Adjusted cell size

            const pixelX = squareX + innerX * cellSize;
            const pixelY = squareY + innerY * cellSize;

            // Add glow effect for your marker
            ctx.shadowColor = "rgba(255, 0, 0, 0.8)";
            ctx.shadowBlur = 5;

            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(
              pixelX + 5 / zoomLevel,
              pixelY + 5 / zoomLevel,
              5 / zoomLevel,
              0,
              Math.PI * 2
            );
            ctx.fill();

            // Reset shadow
            ctx.shadowBlur = 0;

            // Add YOUR location text
            if (zoomLevel > 2) {
              ctx.fillStyle = "white";
              ctx.font = `${12 / zoomLevel}px Arial`;
              ctx.textAlign = "center";
              ctx.fillText(
                "YOU",
                pixelX + 5 / zoomLevel,
                pixelY - 5 / zoomLevel
              );
            }
          }

          // Draw other players' positions
          if (playerPositions && playerPositions.length > 0) {
            playerPositions.forEach((player) => {
              // Skip current user since we already drew it in red
              if (player.user_id === currentUserId) return;

              const pixelX = player.square_x + player.inner_x * (20 / 10);
              const pixelY = player.square_y + player.inner_y * (20 / 10);

              // Add glow effect for other players
              ctx.shadowColor = "rgba(255, 255, 0, 0.6)";
              ctx.shadowBlur = 5;

              ctx.fillStyle = "gold";
              ctx.beginPath();
              ctx.arc(
                pixelX + 5 / zoomLevel,
                pixelY + 5 / zoomLevel,
                4 / zoomLevel,
                0,
                Math.PI * 2
              );
              ctx.fill();

              // Reset shadow
              ctx.shadowBlur = 0;

              // Draw player name if zoomed in enough
              if (zoomLevel > 2) {
                ctx.fillStyle = "white";
                ctx.font = `${10 / zoomLevel}px Arial`;
                ctx.textAlign = "center";
                ctx.fillText(
                  player.username,
                  pixelX + 5 / zoomLevel,
                  pixelY - 5 / zoomLevel
                );
              }
            });
          }
        }

        loadAllPlayers();

        async function syncLocalSectorWithServer() {
          try {
            const token = localStorage.getItem("token");
            if (!token) return false;

            // Get sector data from localStorage
            const sectorKey = `nebulous_sector_${username}`;
            const positionKey = `nebulous_position_${username}`;

            const storedSector = localStorage.getItem(sectorKey);
            const storedPositionData = localStorage.getItem(positionKey);

            if (!storedSector || !storedPositionData) {
              console.log("No local sector data to sync");
              return false;
            }

            // Parse position data
            const position = JSON.parse(storedPositionData);

            console.log(
              "Syncing local sector with server:",
              storedSector,
              position
            );

            // Send data to server
            const response = await fetch("/api/sector/sync", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify({
                sector: storedSector,
                position: position,
              }),
            });

            if (!response.ok) {
              console.error(
                "Failed to sync sector with server:",
                response.status
              );
              return false;
            }

            const data = await response.json();
            console.log("Sector synced successfully:", data);
            return true;
          } catch (error) {
            console.error("Error syncing sector with server:", error);
            return false;
          }
        }

        // Call this function at startup
        document.addEventListener("DOMContentLoaded", function () {
          setTimeout(() => {
            syncLocalSectorWithServer();
          }, 1000); // Wait 1 second after page load to ensure username is available
        });

        // Add this to initializeMap, after loadUserSectorFromServer
        // Modify the existing code:
        loadUserSectorFromServer().then((serverSectorFound) => {
          if (!serverSectorFound) {
            // If no server sector, check local storage (as the code already does)
            console.log("Checking local storage for sector data");

            // If we have local data but not server data, sync it
            if (localStorage.getItem(sectorKey)) {
              syncLocalSectorWithServer();
            }
          } else {
            // Server data loaded, now load all other players
            loadAllPlayers();
            centerOnSelectedPosition();
          }
        });

        // Also add syncLocalSectorWithServer call to the refresh button handler
        document
          .getElementById("refreshMap")
          .addEventListener("click", function () {
            syncLocalSectorWithServer().then(() => {
              loadAllPlayers();
              showSuccess("Player positions refreshed");
            });
          });

        function splitAllSquares() {
          if (clickCount >= 5) return;

          const newSquares = [];
          squares.forEach((square) => {
            if (square.level >= 5) {
              newSquares.push(square);
              return;
            }

            const newSize = square.size / 2;
            const newLevel = square.level + 1;
            newSquares.push(
              { x: square.x, y: square.y, size: newSize, level: newLevel },
              {
                x: square.x + newSize,
                y: square.y,
                size: newSize,
                level: newLevel,
              },
              {
                x: square.x,
                y: square.y + newSize,
                size: newSize,
                level: newLevel,
              },
              {
                x: square.x + newSize,
                y: square.y + newSize,
                size: newSize,
                level: newLevel,
              }
            );
          });

          squares = newSquares;
          drawAllSquares();
        }

        function getPositionFormat(squareX, squareY, innerX, innerY) {
          let format = "";
          let x = squareX / 640;
          let y = squareY / 640;

          for (let level = 0; level < 4; level++) {
            let sectorLetter = "";
            if (x < 0.5 && y < 0.5) {
              sectorLetter = "A";
            } else if (x >= 0.5 && y < 0.5) {
              sectorLetter = "B";
              x -= 0.5;
            } else if (x < 0.5 && y >= 0.5) {
              sectorLetter = "C";
              y -= 0.5;
            } else {
              sectorLetter = "D";
              x -= 0.5;
              y -= 0.5;
            }
            format += sectorLetter;

            x *= 2;
            y *= 2;

            let sectorNumber = "";
            if (x < 0.5 && y < 0.5) {
              sectorNumber = "1";
            } else if (x >= 0.5 && y < 0.5) {
              sectorNumber = "2";
              x -= 0.5;
            } else if (x < 0.5 && y >= 0.5) {
              sectorNumber = "3";
              y -= 0.5;
            } else {
              sectorNumber = "4";
              x -= 0.5;
              y -= 0.5;
            }
            format += sectorNumber;

            x *= 2;
            y *= 2;
          }

          const innerPos = innerY * 10 + innerX;
          format += innerPos.toString().padStart(2, "0");

          return format;
        }

        function updateSectorDisplay(sectorCode) {
          document.getElementById("sector-code").textContent =
            "Sector: " + sectorCode;
          document.getElementById(
            "sector-description"
          ).textContent = `Your assigned sector has been plotted on the map. This location is identified as ${sectorCode}.`;

          document.getElementById("sector-display").style.display = "block";
          document.getElementById("no-sector").style.display = "none";
        }

        function selectRandomPosition() {
          console.log("Selecting random position for user:", username);

          // If a sector is already assigned, don't allow generating a new one
          if (localStorage.getItem(sectorKey)) {
            showError(
              "A sector has already been assigned to you. This cannot be changed."
            );
            return;
          }

          const gridSize = 32;
          const squareSize = 640 / gridSize;

          const randGridX = Math.floor(Math.random() * gridSize);
          const randGridY = Math.floor(Math.random() * gridSize);
          const squareX = randGridX * squareSize;
          const squareY = randGridY * squareSize;

          const innerX = Math.floor(Math.random() * 10);
          const innerY = Math.floor(Math.random() * 10);

          selectedPosition = { squareX, squareY, innerX, innerY };
          const positionFormat = getPositionFormat(
            squareX,
            squareY,
            innerX,
            innerY
          );

          console.log("Generated sector for", username, ":", positionFormat);

          // Update UI with sector info
          updateSectorDisplay(positionFormat);

          // Store the sector code AND position data in localStorage for persistence
          localStorage.setItem(sectorKey, positionFormat);
          localStorage.setItem(positionKey, JSON.stringify(selectedPosition));

          // Disable the generate button after selection
          if (generateBtn) {
            generateBtn.disabled = true;
            generateBtn.textContent = "Sector Assigned";
            document.getElementById("map-instructions").textContent =
              "Your sector has been permanently assigned. You can explore the map by clicking, zooming, and panning.";
          }

          // Send sector data to server
          try {
            const token = localStorage.getItem("token");
            fetch("/api/sector/assign", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify({
                sector: positionFormat,
                position: selectedPosition,
              }),
            })
              .then((response) => {
                if (!response.ok) {
                  console.error(
                    "Failed to save sector to server:",
                    response.status
                  );
                  // If server save fails, still show the sector locally
                }
              })
              .catch((error) => {
                console.error("Error saving sector to server:", error);
              });
          } catch (e) {
            console.error("Error preparing sector data for server:", e);
          }

          // Center the view on the selected position
          centerOnSelectedPosition();

          // Show success message
          showSuccess("Sector successfully assigned: " + positionFormat);

          // Draw everything
          loadAllPlayers();
        }
        async function loadAllPlayers() {
  try {
    const token = localStorage.getItem("token");
    if (!token) return;

    console.log("Loading all player positions...");
    
    // Show a loading indicator in player count
    const playerCountElement = document.getElementById("player-count");
    if (playerCountElement) {
      playerCountElement.textContent = "loading...";
    }

    let serverDataLoaded = false;
    
    try {
      const response = await fetch("/api/sectors/all", {
        headers: {
          "Authorization": `Bearer ${token}`
        }
      });

      if (response.ok) {
        const data = await response.json();
        
        // Handle case where data.sectors might be empty
        if (data.sectors && Array.isArray(data.sectors) && data.sectors.length > 0) {
          playerPositions = data.sectors;
          currentUserId = data.currentUserId;
          serverDataLoaded = true;
          console.log(`Loaded ${playerPositions.length} player positions from server`);
        }
      }
    } catch (error) {
      console.log("Could not load player data from server:", error);
      // We'll use dummy data instead, so no need to show an error
    }
    
    // If we couldn't load data from server or there's only the current user,
    // generate dummy players for demonstration
    if (!serverDataLoaded || playerPositions.length <= 1) {
      generateDummyPlayers();
    }
    
    // Update player count in the UI
    if (playerCountElement && playerPositions) {
      const otherPlayerCount = currentUserId ? 
        playerPositions.filter(p => p.user_id !== currentUserId).length : 
        playerPositions.length - 1;
      
      playerCountElement.textContent = otherPlayerCount;
    }

    console.log(`Player positions ready: ${playerPositions ? playerPositions.length : 0} players`);
    
    // Log the first few entries for debugging
    if (playerPositions && playerPositions.length > 0) {
      console.log("Sample player data:", playerPositions.slice(0, 2));
    }
    
    drawAllSquares(); // Redraw with all players
  } catch (error) {
    console.error("Error in loadAllPlayers:", error);
    // Don't show error to user, just log it
    if (document.getElementById("player-count")) {
      document.getElementById("player-count").textContent = "0";
    }
  }
}
        function centerOnSelectedPosition() {
          if (!selectedPosition) return;

          console.log("Centering on position:", selectedPosition);

          const { squareX, squareY } = selectedPosition;
          const canvasRect = canvas.getBoundingClientRect();

          // Center the view on the selected position
          offsetX = canvasRect.width / 2 - squareX * zoomLevel;
          offsetY = canvasRect.height / 2 - squareY * zoomLevel;

          loadAllPlayers(); // Load all players when centering
          drawAllSquares();
        }
        // Event Listeners
        canvas.addEventListener("click", () => {
          console.log("Canvas clicked, clickCount:", clickCount);
          if (clickCount < 5) {
            clickCount++;
            splitAllSquares();
          }
        });

        canvas.addEventListener("wheel", (e) => {
          e.preventDefault();

          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          const worldXBefore = (mouseX - offsetX) / zoomLevel;
          const worldYBefore = (mouseY - offsetY) / zoomLevel;

          const zoomSpeed = 0.1;
          const zoomDelta = e.deltaY < 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
          zoomLevel *= zoomDelta;

          zoomLevel = Math.max(1, Math.min(zoomLevel, 100));

          const worldXAfter = (mouseX - offsetX) / zoomLevel;
          const worldYAfter = (mouseY - offsetY) / zoomLevel;
          offsetX += (worldXAfter - worldXBefore) * zoomLevel;
          offsetY += (worldYAfter - worldYBefore) * zoomLevel;

          drawAllSquares();
        });

        canvas.addEventListener("mousedown", (e) => {
          isDragging = true;
          dragStartX = e.clientX - offsetX;
          dragStartY = e.clientY - offsetY;
        });

        canvas.addEventListener("mousemove", (e) => {
          if (isDragging) {
            offsetX = e.clientX - dragStartX;
            offsetY = e.clientY - dragStartY;
            drawAllSquares();
          }
        });

        canvas.addEventListener("mouseup", () => {
          isDragging = false;
        });

        canvas.addEventListener("mouseleave", () => {
          isDragging = false;
        });

        // Generate sector button
        if (generateBtn) {
          generateBtn.addEventListener("click", () => {
            console.log("Generate sector button clicked for user:", username);

            // Double-check if a sector already exists
            if (localStorage.getItem(sectorKey)) {
              showError(
                "A sector has already been assigned to you. This cannot be changed."
              );
              generateBtn.disabled = true;
              return;
            }

            clickCount = 5; // Reset to allow for sector generation
            selectRandomPosition();
            clickCount = 6; // Increment to prevent further automatic selection
          });
        } else {
          console.error("Generate sector button not found!");
        }

        // Check if a sector has already been generated
        if (storedSector) {
          console.log("Found stored sector for", username, ":", storedSector);
          document.getElementById("sector-code").textContent =
            "Sector: " + storedSector;
          document.getElementById(
            "sector-description"
          ).textContent = `Your assigned sector is ${storedSector}. This location is permanently assigned to you.`;

          document.getElementById("sector-display").style.display = "block";
          document.getElementById("no-sector").style.display = "none";
        }

        // Initial drawing happens after image load or in the error handler
        console.log("Map initialization complete for user:", username);
      }

      async function diagnoseSectors() {
        try {
          const token = localStorage.getItem("token");
          if (!token) {
            showError("Not logged in");
            return;
          }

          // Show loading message
          showSuccess("Running diagnostics...");

          // Call the diagnostic endpoint
          const response = await fetch("/api/sectors/diagnose", {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });

          if (!response.ok) {
            showError(`Diagnostic failed: ${response.status}`);
            return;
          }

          const data = await response.json();

          // Create a diagnostic message
          let message = `
      <strong>Sector Diagnostics:</strong><br>
      Table exists: ${data.tableExists ? "Yes" : "No"}<br>
      Total sectors: ${data.sectorCount}<br>
      Errors found: ${data.errorEntries.length}<br>
      Recent entries: ${data.recentEntries.length}<br>
      <br>
      <strong>Local Storage:</strong><br>
      Username: ${username}<br>
      Sector key: ${
        localStorage.getItem(`nebulous_sector_${username}`) || "Not set"
      }<br>
      Position data: ${
        localStorage.getItem(`nebulous_position_${username}`)
          ? "Set"
          : "Not set"
      }<br>
      <br>
      <strong>Recent entries:</strong><br>
      ${data.recentEntries
        .map((entry) => `User: ${entry.username}, Sector: ${entry.sector_code}`)
        .join("<br>")}
    `;

          // Display it
          const diagElement = document.createElement("div");
          diagElement.className = "diagnostic-popup";
          diagElement.innerHTML = `
      <div class="diagnostic-content">
        <h3>Sector Diagnostics</h3>
        <div class="diagnostic-info">${message}</div>
        <button id="closeDiag" class="btn btn-primary">Close</button>
        <button id="forceSyncDiag" class="btn btn-warning">Force Sync</button>
      </div>
    `;

          document.body.appendChild(diagElement);

          // Add event listeners to buttons
          document.getElementById("closeDiag").addEventListener("click", () => {
            document.body.removeChild(diagElement);
          });

          document
            .getElementById("forceSyncDiag")
            .addEventListener("click", async () => {
              document.body.removeChild(diagElement);
              await syncLocalSectorWithServer();
              loadAllPlayers();
              showSuccess("Force sync completed");
            });

          // Add some basic styling
          const style = document.createElement("style");
          style.textContent = `
      .diagnostic-popup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      .diagnostic-content {
        background-color: #222;
        border: 1px solid #444;
        border-radius: 5px;
        padding: 20px;
        max-width: 80%;
        max-height: 80%;
        overflow-y: auto;
      }
      .diagnostic-info {
        margin: 15px 0;
        white-space: pre-line;
        text-align: left;
      }
    `;
          document.head.appendChild(style);
        } catch (error) {
          console.error("Error running diagnostics:", error);
          showError("Diagnostic error: " + error.message);
        }
      }

      // Add event listener for the diagnose button
      document
        .getElementById("diagnoseSectors")
        .addEventListener("click", diagnoseSectors);


        function calculateDistanceLightYears(pos1, pos2) {
  // Universe dimensions
  const UNIVERSE_WIDTH = 640;
  const UNIVERSE_HEIGHT = 640;
  const INNER_GRID = 10;
  const TOTAL_LIGHT_YEARS = 81920000000; // 81.92 billion light years
  
  // Extract coordinates
  const x1 = parseFloat(pos1.squareX) + (parseFloat(pos1.innerX) / INNER_GRID);
  const y1 = parseFloat(pos1.squareY) + (parseFloat(pos1.innerY) / INNER_GRID);
  const x2 = parseFloat(pos2.squareX) + (parseFloat(pos2.innerX) / INNER_GRID);
  const y2 = parseFloat(pos2.squareY) + (parseFloat(pos2.innerY) / INNER_GRID);
  
  // Calculate Euclidean distance in grid units
  const deltaX = x2 - x1;
  const deltaY = y2 - y1;
  const gridDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  
  // Calculate diagonal of universe
  const universeDiagonal = Math.sqrt(
    UNIVERSE_WIDTH * UNIVERSE_WIDTH + 
    UNIVERSE_HEIGHT * UNIVERSE_HEIGHT
  );
  
  // Convert to light years
  const lightYearDistance = (gridDistance / universeDiagonal) * TOTAL_LIGHT_YEARS;
  const percentageOfUniverse = (gridDistance / universeDiagonal) * 100;
  
  return {
    gridDistance: gridDistance,
    lightYears: lightYearDistance,
    formattedLightYears: formatLightYears(lightYearDistance),
    percentageOfUniverse: percentageOfUniverse,
    travelTimeEstimate: estimateTravelTime(lightYearDistance)
  };
}

function formatLightYears(lightYears) {
  // Format as full number with commas
  return lightYears.toLocaleString(undefined, {
    maximumFractionDigits: 0
  }) + " light years";
}

function estimateTravelTime(lightYears) {
  const WARP_FACTOR_9 = 0.25;
  const WARP_FACTOR_MAX = 0.05;
  const QUANTUM_SLIPSTREAM = 0.001;
  const TRANSWARP_CONDUIT = 0.0001;
  
  return {
    warpFactor9: formatTravelTime(lightYears * WARP_FACTOR_9),
    warpFactorMax: formatTravelTime(lightYears * WARP_FACTOR_MAX),
    quantumSlipstream: formatTravelTime(lightYears * QUANTUM_SLIPSTREAM),
    transwarpConduit: formatTravelTime(lightYears * TRANSWARP_CONDUIT),
  };
}

function formatTravelTime(years) {
  if (years < 1) {
    const days = years * 365;
    if (days < 1) {
      const hours = days * 24;
      if (hours < 1) {
        const minutes = hours * 60;
        return minutes.toFixed(1) + " minutes";
      }
      return hours.toFixed(1) + " hours";
    }
    return days.toFixed(1) + " days";
  }
  
  // Format as full number with commas
  return years.toLocaleString(undefined, {
    maximumFractionDigits: 0
  }) + " years";
}

// Initialize the distance calculator UI once the map is initialized
function initDistanceCalculator() {
  // Button to calculate distance between custom coordinates
  document.getElementById("calculate-distance").addEventListener("click", function() {
    // Get coordinates from form
    const position1 = {
      squareX: document.getElementById("pos1-square-x").value,
      squareY: document.getElementById("pos1-square-y").value,
      innerX: document.getElementById("pos1-inner-x").value,
      innerY: document.getElementById("pos1-inner-y").value
    };
    
    const position2 = {
      squareX: document.getElementById("pos2-square-x").value,
      squareY: document.getElementById("pos2-square-y").value,
      innerX: document.getElementById("pos2-inner-x").value,
      innerY: document.getElementById("pos2-inner-y").value
    };
    
    // Validate input - make sure all fields have values
    for (const key in position1) {
      if (!position1[key]) {
        showError(`Position 1 ${key} is required`);
        return;
      }
    }
    
    for (const key in position2) {
      if (!position2[key]) {
        showError(`Position 2 ${key} is required`);
        return;
      }
    }
    
    // Calculate distance client-side
    const distance = calculateDistanceLightYears(position1, position2);
    
    // Update UI with results
    document.getElementById("grid-distance").textContent = distance.gridDistance.toFixed(2);
    document.getElementById("light-years-distance").textContent = distance.formattedLightYears;
    document.getElementById("universe-percentage").textContent = distance.percentageOfUniverse.toFixed(4);
    
    document.getElementById("travel-warp9").textContent = distance.travelTimeEstimate.warpFactor9;
    document.getElementById("travel-warp-max").textContent = distance.travelTimeEstimate.warpFactorMax;
    document.getElementById("travel-quantum").textContent = distance.travelTimeEstimate.quantumSlipstream;
    document.getElementById("travel-transwarp").textContent = distance.travelTimeEstimate.transwarpConduit;
    
    // Show the results
    document.getElementById("distance-result").style.display = "block";
  });
  
  // Button to use current player's position
  document.getElementById("use-my-position").addEventListener("click", function() {
    if (!selectedPosition) {
      showError("Your position is not available");
      return;
    }
    
    document.getElementById("pos1-square-x").value = selectedPosition.squareX;
    document.getElementById("pos1-square-y").value = selectedPosition.squareY;
    document.getElementById("pos1-inner-x").value = selectedPosition.innerX;
    document.getElementById("pos1-inner-y").value = selectedPosition.innerY;
  });
  
  // Button to get distances to all other players
  document.getElementById("get-player-distances").addEventListener("click", function() {
  try {
    // Reset button state
    document.getElementById("get-player-distances").textContent = "Calculate Player Distances";
    document.getElementById("get-player-distances").disabled = false;
    
    // Check if we have any other players
    if (!playerPositions || playerPositions.length === 0 || !currentUserId) {
      document.getElementById("player-distances-result").style.display = "none";
      document.getElementById("no-players-message").style.display = "block";
      return;
    }
    
    // Get current player's position
    const currentPlayer = playerPositions.find(p => p.user_id === currentUserId);
    
    if (!currentPlayer) {
      showError("Your position data is not available");
      return;
    }
    
    // Set your sector code
    document.getElementById("your-sector-code").textContent = currentPlayer.sector_code || "Unknown";
    
    // Get other players
    const otherPlayers = playerPositions.filter(p => p.user_id !== currentUserId);
    
    if (otherPlayers.length === 0) {
      document.getElementById("player-distances-result").style.display = "none";
      document.getElementById("no-players-message").style.display = "block";
      return;
    }
    
    // Hide no players message
    document.getElementById("no-players-message").style.display = "none";
    
    // Clear existing table
    const tableBody = document.getElementById("player-distances-table");
    tableBody.innerHTML = "";
    
    // Current player position
    const myPosition = {
      squareX: currentPlayer.square_x,
      squareY: currentPlayer.square_y,
      innerX: currentPlayer.inner_x,
      innerY: currentPlayer.inner_y
    };
    
    // Calculate distances to each other player
    const playerDistances = otherPlayers.map(player => {
      const otherPosition = {
        squareX: player.square_x,
        squareY: player.square_y,
        innerX: player.inner_x,
        innerY: player.inner_y
      };
      
      const distance = calculateDistanceLightYears(myPosition, otherPosition);
      
      return {
        userId: player.user_id,
        username: player.username,
        sector: player.sector_code,
        distance: distance
      };
    });
    
    // Sort by distance (closest first)
    playerDistances.sort((a, b) => a.distance.lightYears - b.distance.lightYears);
    
    // Populate table with player distances
    playerDistances.forEach(player => {
      const row = document.createElement("tr");
      
      row.innerHTML = `
        <td>${player.username || 'Unknown Player'}</td>
        <td>${player.sector || 'Unknown Sector'}</td>
        <td>${player.distance.formattedLightYears}</td>
        <td>${player.distance.travelTimeEstimate.quantumSlipstream}</td>
      `;
      
      tableBody.appendChild(row);
    });
    
    // Show results
    document.getElementById("player-distances-result").style.display = "block";
    
  } catch (error) {
    console.error("Error getting player distances:", error);
    showError("Error: " + error.message);
    document.getElementById("player-distances-result").style.display = "none";
  }
});
}
// Add this to your document ready function or at the end of initializeMap
document.addEventListener("DOMContentLoaded", function() {
  setTimeout(() => {
    initDistanceCalculator();
  }, 1500); // Wait for the map to initialize first
});




// First, declare these variables in the global scope of your script
let playerPositions = [];
let currentUserId = null;

// Remove all existing get-player-distances event listeners and create a single new one
function initPlayerDistancesButton() {
  console.log("Initializing player distances button");
  const button = document.getElementById("get-player-distances");
  
  // Remove existing handlers by cloning and replacing the button
  if (button) {
    const newButton = button.cloneNode(true);
    button.parentNode.replaceChild(newButton, button);
    
    // Add the new event handler
    newButton.addEventListener("click", function() {
      console.log("Player distances button clicked");
      showPlayerDistances();
    });
  } else {
    console.error("Player distances button not found");
  }
}

// Function to show player distances
function showPlayerDistances() {
  console.log("Showing player distances");
  
  // First, check if we have our position
  if (!selectedPosition) {
    showError("Your position is not available. Please generate a sector first.");
    return;
  }
  
  // Create a simple table with a few sample players at different distances
  const tableBody = document.getElementById("player-distances-table");
  if (!tableBody) {
    console.error("Could not find player-distances-table element");
    return;
  }
  
  // Clear the table
  tableBody.innerHTML = "";
  
  // Set your sector code
  const sectorCode = localStorage.getItem(`nebulous_sector_${username}`) || "Unknown";
  document.getElementById("your-sector-code").textContent = sectorCode;
  
  // Create some sample positions at different distances
  const samplePlayers = [
    {
      username: "NearbyExplorer",
      sector: "A1B2C3D455",
      position: {
        squareX: selectedPosition.squareX + 20,
        squareY: selectedPosition.squareY + 15,
        innerX: 5,
        innerY: 7
      }
    },
    {
      username: "DistantVoyager",
      sector: "D4C3B2A187",
      position: {
        squareX: selectedPosition.squareX - 100,
        squareY: selectedPosition.squareY + 200,
        innerX: 2,
        innerY: 3
      }
    },
    {
      username: "GalacticNomad",
      sector: "B3A4D1C292",
      position: {
        squareX: selectedPosition.squareX + 300,
        squareY: selectedPosition.squareY - 180,
        innerX: 8,
        innerY: 1
      }
    }
  ];
  
  // Calculate distances for each sample player
  samplePlayers.forEach(player => {
    const myPosition = {
      squareX: selectedPosition.squareX,
      squareY: selectedPosition.squareY,
      innerX: selectedPosition.innerX,
      innerY: selectedPosition.innerY
    };
    
    const distance = calculateDistanceLightYears(myPosition, player.position);
    
    // Create a row for this player
    const row = document.createElement("tr");
    row.innerHTML = `
      <td>${player.username}</td>
      <td>${player.sector}</td>
      <td>${distance.formattedLightYears}</td>
      <td>${distance.travelTimeEstimate.quantumSlipstream}</td>
    `;
    
    tableBody.appendChild(row);
  });
  
  // Show the results
  document.getElementById("player-distances-result").style.display = "block";
  document.getElementById("no-players-message").style.display = "none";
}

// Function to manually initialize tabs
function initTabs() {
  console.log("Initializing tabs manually");
  
  // Get all tab buttons
  const tabButtons = document.querySelectorAll('[data-bs-toggle="tab"]');
  
  // For each tab button
  tabButtons.forEach(button => {
    button.addEventListener('click', function(event) {
      event.preventDefault();
      
      // Get the target tab content
      const targetId = this.getAttribute('data-bs-target');
      const targetTab = document.querySelector(targetId);
      
      if (!targetTab) {
        console.error("Target tab not found:", targetId);
        return;
      }
      
      // Hide all tab contents
      document.querySelectorAll('.tab-pane').forEach(tab => {
        tab.classList.remove('show', 'active');
      });
      
      // Show the selected tab content
      targetTab.classList.add('show', 'active');
      
      // Mark this button as active
      document.querySelectorAll('[data-bs-toggle="tab"]').forEach(tab => {
        tab.classList.remove('active');
      });
      this.classList.add('active');
      
      console.log("Switched to tab:", targetId);
    });
  });
}

// Initialize everything at the right time
document.addEventListener("DOMContentLoaded", function() {
  // First make sure we wait for the map to initialize
  setTimeout(() => {
    console.log("Initializing distance calculator components");
    
    // Initialize tabs
    initTabs();
    
    // Initialize the distance calculator
    initDistanceCalculator();
    
    // Initialize the player distances button
    initPlayerDistancesButton();
    
    // Log success
    console.log("Distance calculator components initialized");
  }, 2000); // Slightly longer timeout to make sure everything else is ready
});
    </script>
  </body>
</html>
